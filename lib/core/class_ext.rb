
#
# We re-open class here, after Hash and Symbol has ben initialized, to add the 
# method -> vtable offset mapping.
#

class Class
  @method_to_voff = {}

  def self.method_to_voff
    @method_to_voff
  end

  # This is called by __send__
  def __send_for_obj__ obj,sym,*args
    voff = Class.method_to_voff[sym]
    if !voff
      %s(printf "WARNING: __send__ bypassing vtable (name not statically known at compile time) not yet implemented.\n")
      %s(if sym (printf "WARNING:    Method: '%s'\n" (callm (callm sym to_s) __get_raw)))
      %s(printf "WARNING:    symbol address = %p\n" sym)
      %s(printf "WARNING:    object = %p\n" obj)
      %s(printf "WARNING:    class '%s'\n" (callm (callm self name) __get_raw))
      %s(div 1 0)
      nil
    else
      # We can't inline this in the call, as our updated callm
      # doesn't allow method/function calls in the method slot
      # for simplicity, for now anyway.
      %s(assign raw (callm voff __get_raw))
      %s(callm obj (index self raw) ((splat args)))
    end
  end

  # FIXME: Belongs in Kernel
end


#
# Populate the Class.method_to_voff hash based on the __vtable_names
# table that gets generated by the compiler.
#
%s(let (i max)
   (assign i 0)
   (assign max __vtable_size)
   (assign h (callm Class method_to_voff))
   (while (lt i max) 
      (do
         (if (ne (index __vtable_names i) 0)
            (callm h []= ((__get_symbol (index __vtable_names i)) (__get_fixnum i)))
            )
          (assign i (add i 1))
      )
   )
)
